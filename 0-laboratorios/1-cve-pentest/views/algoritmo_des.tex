\section{Análisis del Algoritmo DES en el Código}

\begin{cryptomethod}{Proceso General del Algoritmo DES}
	El algoritmo DES cifra bloques de 64 bits utilizando una clave de 56 bits efectivos para producir bloques cifrados de 64 bits. Su estructura sigue un esquema de red de Feistel con 16 rondas, donde cada ronda utiliza una subclave derivada de la clave principal.

	El proceso completo puede resumirse en las siguientes etapas:
	\begin{enumerate}
		\item \textbf{Permutación Inicial}: Reordenación de los bits del bloque según una tabla predefinida
		\item \textbf{División del bloque}: Separación en mitades izquierda ($L_0$) y derecha ($R_0$)
		\item \textbf{16 rondas de procesamiento}: Aplicación iterativa de la función de Feistel
		\item \textbf{Intercambio final}: Combinación de las mitades como $R_{16}L_{16}$
		\item \textbf{Permutación Final}: Aplicación de la permutación inversa a la inicial
	\end{enumerate}

	La estructura de Feistel en cada ronda se define matemáticamente como:
	\begin{align}
		L_i & = R_{i-1}                        \\
		R_i & = L_{i-1} \oplus f(R_{i-1}, K_i)
	\end{align}
	donde $f$ es la función principal de DES.
\end{cryptomethod}

\subsection{a. Permutación Inicial (IP)}

\begin{cryptoanalysis}{Permutación Inicial}
	La permutación inicial reordena los 64 bits de entrada según una tabla fija sin propósito criptográfico real, sino para facilitar la implementación en hardware.

	Matemáticamente, si denotamos el bloque de entrada como $B = (b_1, b_2, \ldots, b_{64})$, la permutación inicial $IP$ produce:
	\begin{align}
		IP(B) = (b_{IP[1]}, b_{IP[2]}, \ldots, b_{IP[64]})
	\end{align}

	donde $IP[i]$ representa el valor de la tabla de permutación en la posición $i$.
\end{cryptoanalysis}

\begin{lstlisting}[style=cryptoalgo, caption={Tabla de Permutación Inicial}, label=lst:ip]
IPtable = (58, 50, 42, 34, 26, 18, 10, 2,
           60, 52, 44, 36, 28, 20, 12, 4,
           62, 54, 46, 38, 30, 22, 14, 6,
           64, 56, 48, 40, 32, 24, 16, 8,
           57, 49, 41, 33, 25, 17,  9, 1,
           59, 51, 43, 35, 27, 19, 11, 3,
           61, 53, 45, 37, 29, 21, 13, 5,
           63, 55, 47, 39, 31, 23, 15, 7)
\end{lstlisting}

En el código, la permutación inicial se aplica en las funciones \texttt{encryptBlock} y \texttt{decryptBlock}:

\begin{lstlisting}[style=cryptoalgo]
inputData = permByteList(inputBlock, IPtable)
\end{lstlisting}

La función \texttt{permByteList} realiza la permutación a nivel de bytes, manejando las manipulaciones de bits necesarias.

\subsection{b. División en Bloques}

\begin{cryptomethod}{División en Bloques}
	Después de la permutación inicial, el bloque de 64 bits se divide en dos mitades de 32 bits cada una:
	\begin{align}
		L_0 & = IP(B)[1:32]  \\
		R_0 & = IP(B)[33:64]
	\end{align}

	Esta división es fundamental para la estructura de Feistel, que permite utilizar la misma implementación tanto para cifrado como para descifrado, simplemente invirtiendo el orden de las subclaves.
\end{cryptomethod}

En el código, esta división se realiza con una simple asignación Python:

\begin{lstlisting}[style=cryptoalgo]
leftPart, rightPart = inputData[:4], inputData[4:]
\end{lstlisting}

Observe que se utilizan 4 bytes para cada mitad (4 bytes × 8 bits = 32 bits).

\subsection{c. Función de DES}

\begin{cryptoanalysis}{Función Principal de DES}
	La función $f$ es el componente central del algoritmo y consta de cuatro operaciones principales:
	\begin{enumerate}
		\item \textbf{Expansión}: El bloque $R_{i-1}$ de 32 bits se expande a 48 bits
		\item \textbf{Mezcla con clave}: Se aplica XOR entre el resultado expandido y la subclave $K_i$
		\item \textbf{Sustitución}: El resultado se divide en 8 bloques de 6 bits que pasan por las S-Boxes
		\item \textbf{Permutación}: Los 32 bits resultantes se reordenan según una tabla fija
	\end{enumerate}

	Matemáticamente:
	\begin{align}
		f(R_{i-1}, K_i) = P(S(E(R_{i-1}) \oplus K_i))
	\end{align}
	donde:
	\begin{itemize}
		\item $E$ es la función de expansión
		\item $S$ representa las sustituciones mediante S-Boxes
		\item $P$ es la permutación interna
	\end{itemize}
\end{cryptoanalysis}

En el código, la función $f$ se implementa dentro de los bucles de las funciones;\\ \texttt{encryptBlock} y \texttt{decryptBlock}:

\begin{lstlisting}[style=cryptoalgo]
# Expansión
expRightPart = permByteList(rightPart, EPtable)

# Mezcla con subclave
key = subKeyList[round]  # O subKeyList[15-round] para descifrado
indexList = byte2Bit([i^j for i,j in zip(key, expRightPart)])

# Sustitución mediante S-Boxes
sBoxOutput = 4*[0]
for nBox in range(4):
    nBox12 = 12*nBox
    leftIndex = getIndex(indexList[nBox12:nBox12+6])
    rightIndex = getIndex(indexList[nBox12+6:nBox12+12])
    sBoxOutput[nBox] = (sBox[nBox<<1][leftIndex]<<4)+ \
                        sBox[(nBox<<1)+1][rightIndex]

# Permutación P
aux = permByteList(sBoxOutput, PFtable)

# XOR con la mitad izquierda para generar la nueva mitad derecha
newRightPart = [i^j for i,j in zip(aux, leftPart)]
\end{lstlisting}

\begin{securitygoodpractice}
	Observación sobre la implementación: El código maneja eficientemente los 8 bloques de 6 bits agrupándolos en pares, procesando 4 pares en lugar de 8 bloques individuales. Por eso vemos operaciones como \texttt{(nBox<<1)} y \texttt{(nBox<<1)+1} para acceder a las S-Boxes correspondientes.
\end{securitygoodpractice}

\subsection{d. Transformación de la Clave}

\begin{cryptomethod}{Generación de Subclaves}
	El proceso para generar las 16 subclaves $K_1$ a $K_{16}$ sigue estos pasos:

	\begin{enumerate}
		\item \textbf{Permutación PC-1}: Reduce la clave de 64 a 56 bits (eliminando bits de paridad)
		\item \textbf{División}: Separa la clave permutada en dos mitades $C_0$ y $D_0$ de 28 bits
		\item \textbf{Rotaciones}: En cada ronda $i$, genera $C_i$ y $D_i$ rotando $C_{i-1}$ y $D_{i-1}$ a la izquierda
		\item \textbf{Permutación PC-2}: Combina $C_i$ y $D_i$ y selecciona 48 bits para formar $K_i$
	\end{enumerate}

	Las rotaciones siguen un patrón específico: se rota 1 posición en las rondas 1, 2, 9 y 16, y 2 posiciones en las demás rondas.

	Matemáticamente:
	\begin{align}
		C_i & = \text{RotateLeft}(C_{i-1}, \text{ShiftBits}[i]) \\
		D_i & = \text{RotateLeft}(D_{i-1}, \text{ShiftBits}[i]) \\
		K_i & = \text{PC-2}(C_i || D_i)
	\end{align}
	donde $||$ denota la concatenación.
\end{cryptomethod}

En el código, la generación de subclaves se implementa en la función \texttt{setKey}:

\begin{lstlisting}[style=cryptoalgo]
def setKey(keyByteList):
    """Generate all sixteen round subkeys"""
    PC1table = (57, 49, 41, 33, 25, 17,  9,
                 1, 58, 50, 42, 34, 26, 18,
                10,  2, 59, 51, 43, 35, 27,
                19, 11,  3, 60, 52, 44, 36,
                63, 55, 47, 39, 31, 23, 15,
                 7, 62, 54, 46, 38, 30, 22,
                14,  6, 61, 53, 45, 37, 29,
                21, 13,  5, 28, 20, 12,  4)

    PC2table= (14, 17, 11, 24,  1,  5,  3, 28,
               15,  6, 21, 10, 23, 19, 12,  4,
               26,  8, 16,  7, 27, 20, 13,  2,
               41, 52, 31, 37, 47, 55, 30, 40,
               51, 45, 33, 48, 44, 49, 39, 56,
               34, 53, 46, 42, 50, 36, 29, 32)

    # Aplicar PC-1 a la clave
    permKeyBitList = permBitList(byte2Bit(keyByteList), PC1table)

    # Generar las 16 subclaves mediante rotaciones y PC-2
    for round in range(16):
        auxBitList = leftShift(permKeyBitList, round)
        subKeyList[round] = bit2Byte(permBitList(auxBitList, PC2table))
        permKeyBitList = auxBitList
\end{lstlisting}

La función \texttt{leftShift} implementa las rotaciones según la tabla \texttt{LStable}:

\begin{lstlisting}[style=cryptoalgo]
def leftShift(inKeyBitList, round):
    """Perform one (or two) circular left shift(s) on key"""
    LStable = (1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1)

    outKeyBitList = 56*[0]
    if LStable[round] == 2:
        # Rotación de 2 posiciones
        outKeyBitList[:26] = inKeyBitList[2:28]
        outKeyBitList[26] = inKeyBitList[0]
        outKeyBitList[27] = inKeyBitList[1]
        outKeyBitList[28:54] = inKeyBitList[30:]
        outKeyBitList[54] = inKeyBitList[28]
        outKeyBitList[55] = inKeyBitList[29]
    else:
        # Rotación de 1 posición
        outKeyBitList[:27] = inKeyBitList[1:28]
        outKeyBitList[27] = inKeyBitList[0]
        outKeyBitList[28:55] = inKeyBitList[29:]
        outKeyBitList[55] = inKeyBitList[28]
    return outKeyBitList
\end{lstlisting}

\subsection{e. Matriz de Expansión}

\begin{cryptomethod}{Expansión E}
	La matriz de expansión E convierte un bloque de 32 bits en uno de 48 bits. Esta expansión tiene dos propósitos:
	\begin{itemize}
		\item Igualar el tamaño del bloque al de la subclave (48 bits)
		\item Mejorar la difusión, haciendo que cada bit afecte a más bits en las siguientes operaciones
	\end{itemize}

	La expansión sigue un patrón específico donde algunos bits aparecen en dos posiciones diferentes del resultado.

	Si denotamos el bloque de entrada como $R = (r_1, r_2, \ldots, r_{32})$, la expansión $E$ produce:
	\begin{align}
		E(R) = (r_{E[1]}, r_{E[2]}, \ldots, r_{E[48]})
	\end{align}
\end{cryptomethod}

\begin{lstlisting}[style=cryptoalgo, caption={Matriz de Expansión E}, label=lst:expansion]
EPtable = (32,  1,  2,  3,  4,  5,
            4,  5,  6,  7,  8,  9,
            8,  9, 10, 11, 12, 13,
           12, 13, 14, 15, 16, 17,
           16, 17, 18, 19, 20, 21,
           20, 21, 22, 23, 24, 25,
           24, 25, 26, 27, 28, 29,
           28, 29, 30, 31, 32,  1)
\end{lstlisting}

En el código, la expansión se aplica mediante la función \texttt{permByteList}:

\begin{lstlisting}[style=cryptoalgo]
expRightPart = permByteList(rightPart, EPtable)
\end{lstlisting}

\begin{securitygoodpractice}
	Patrón de expansión: Observe que la tabla de expansión repite ciertos números, indicando que algunos bits aparecen dos veces en la salida. Específicamente, los bits en las posiciones extremas de cada grupo de 4 bits se duplican, creando una importante difusión en el algoritmo.
\end{securitygoodpractice}

\subsection{f. Cajas de Sustitución (S-Boxes)}

\begin{cryptoanalysis}{Cajas de Sustitución (S-Boxes)}
	Las S-Boxes son el componente no lineal de DES y constituyen su núcleo criptográfico. Cada una de las 8 cajas S toma 6 bits de entrada y produce 4 bits de salida según tablas predefinidas.

	La entrada de 6 bits se interpreta de manera especial:
	\begin{itemize}
		\item Los bits 1 y 6 determinan la fila (0-3) de la tabla
		\item Los bits 2, 3, 4 y 5 determinan la columna (0-15)
	\end{itemize}

	Matemáticamente, si denotamos la entrada a la $i$-ésima S-Box como $B_i = (b_1, b_2, b_3, b_4, b_5, b_6)$, entonces:
	\begin{align}
		\text{fila}    & = 2 \cdot b_1 + b_6                                \\
		\text{columna} & = 8 \cdot b_2 + 4 \cdot b_3 + 2 \cdot b_4 + b_5    \\
		S_i(B_i)       & = \text{ValorTabla}_{i,\text{fila},\text{columna}}
	\end{align}
\end{cryptoanalysis}

\begin{lstlisting}[style=cryptoalgo, caption={Definición de S-Boxes}, label=lst:sboxes]
sBox = 8*[64*[0]]

sBox[0] = (14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
            0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
            4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
           15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13)

# Continúan definiciones para sBox[1] hasta sBox[7]...
\end{lstlisting}

La función \texttt{getIndex} calcula el índice correcto para acceder a la S-Box:

\begin{lstlisting}[style=cryptoalgo]
def getIndex(inBitList):
    """Permute bits to properly index the S-boxes"""
    return (inBitList[0]<<5)+(inBitList[1]<<3)+ \
           (inBitList[2]<<2)+(inBitList[3]<<1)+ \
           (inBitList[4]<<0)+(inBitList[5]<<4)
\end{lstlisting}

\begin{securitywarning}
	La manipulación de bits en la función \texttt{getIndex} parece confusa, pero implementa la fórmula para calcular el índice combinando los bits 1 y 6 para la fila, y los bits 2-5 para la columna. La expresión reordena los bits para formar el índice adecuado.
\end{securitywarning}

Aplicación de las S-Boxes en el código:

\begin{lstlisting}[style=cryptoalgo]
for nBox in range(4):
    nBox12 = 12*nBox
    leftIndex = getIndex(indexList[nBox12:nBox12+6])
    rightIndex = getIndex(indexList[nBox12+6:nBox12+12])
    sBoxOutput[nBox] = (sBox[nBox<<1][leftIndex]<<4)+ \
                        sBox[(nBox<<1)+1][rightIndex]
\end{lstlisting}

\subsection{g. Permutación Final}

\begin{cryptomethod}{Permutación Final}
	La permutación final (IP$^{-1}$) es la inversa matemática de la permutación inicial. Su papel es revertir la reordenación inicial, completando el proceso criptográfico.

	Antes de aplicar esta permutación, las mitades derecha e izquierda se intercambian, formando $R_{16}L_{16}$ en lugar de $L_{16}R_{16}$.

	Si denotamos el bloque intercambiado como $X = R_{16}L_{16}$, entonces la permutación final produce:
	\begin{align}
		\text{IP}^{-1}(X) = (x_{\text{IP}^{-1}[1]}, x_{\text{IP}^{-1}[2]}, \ldots, x_{\text{IP}^{-1}[64]})
	\end{align}
\end{cryptomethod}

\begin{lstlisting}[style=cryptoalgo, caption={Tabla de Permutación Final}, label=lst:permutacion-final]
FPtable = (40, 8, 48, 16, 56, 24, 64, 32,
           39, 7, 47, 15, 55, 23, 63, 31,
           38, 6, 46, 14, 54, 22, 62, 30,
           37, 5, 45, 13, 53, 21, 61, 29,
           36, 4, 44, 12, 52, 20, 60, 28,
           35, 3, 43, 11, 51, 19, 59, 27,
           34, 2, 42, 10, 50, 18, 58, 26,
           33, 1, 41,  9, 49, 17, 57, 25)
\end{lstlisting}

En el código, después de las 16 rondas, se aplica la permutación final:

\begin{lstlisting}[style=cryptoalgo]
return permByteList(rightPart+leftPart, FPtable)
\end{lstlisting}

\section{Aspectos Destacables de la Implementación}

\begin{securitygoodpractice}
	\textbf{Simetría en Cifrado/Descifrado}: La implementación aprovecha la propiedad de la red de Feistel para realizar descifrado con el mismo algoritmo que el cifrado, simplemente invirtiendo el orden de las subclaves:

	\begin{lstlisting}[style=cryptoalgo]
# En encryptBlock:
key = subKeyList[round]

# En decryptBlock:
key = subKeyList[15-round]
\end{lstlisting}
\end{securitygoodpractice}

\begin{cryptoanalysis}{Funcionamiento Completo}
	El algoritmo DES completo puede resumirse en el siguiente diagrama de flujo matemático:

	\textbf{Cifrado:}
	\begin{align}
		\text{Texto cifrado} & = \text{IP}^{-1}(R_{16}L_{16})                                           \\
		\text{donde:}                                                                                   \\
		L_0R_0               & = \text{IP}(\text{Texto plano})                                          \\
		L_i                  & = R_{i-1} \quad \text{para } i = 1, 2, \ldots, 16                        \\
		R_i                  & = L_{i-1} \oplus f(R_{i-1}, K_i) \quad \text{para } i = 1, 2, \ldots, 16
	\end{align}

	\textbf{Descifrado:}
	\begin{align}
		\text{Texto plano} & = \text{IP}^{-1}(R_{16}L_{16})                                                \\
		\text{donde:}                                                                                      \\
		L_0R_0             & = \text{IP}(\text{Texto cifrado})                                             \\
		L_i                & = R_{i-1} \quad \text{para } i = 1, 2, \ldots, 16                             \\
		R_i                & = L_{i-1} \oplus f(R_{i-1}, K_{17-i}) \quad \text{para } i = 1, 2, \ldots, 16
	\end{align}
\end{cryptoanalysis}

\begin{securityalert}
	A pesar de la elegancia matemática del diseño DES, es importante recordar que actualmente no se considera seguro debido a su tamaño de clave efectivo de 56 bits, que puede ser quebrado por fuerza bruta. Para aplicaciones modernas, se recomiendan algoritmos como AES con claves de al menos 128 bits.
\end{securityalert}