\section{Análisis del Algoritmo DES}

\subsection{Visión General del Algoritmo}

El Data Encryption Standard (DES) es un algoritmo de cifrado simétrico por bloques desarrollado en la década de 1970 por IBM y posteriormente adoptado como estándar por el gobierno de Estados Unidos. DES opera sobre bloques de 64 bits, utilizando una clave de 56 bits efectivos (64 bits incluyendo bits de paridad).

interpretar diagramas, con desc logica

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}[node distance=1.5cm]
%     % Bloques
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, below of=bloque] (pi) {Permutación Inicial (IP)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, below of=pi] (div) {División L$_0$ y R$_0$};
%     \node[rectangle, draw, minimum width=3cm, minimum height=1.5cm, below=1.2cm of div] (rondas) {16 Rondas de Procesamiento\newline L$_i$ = R$_{i-1}$\newline R$_i$ = L$_{i-1}$ $\oplus$ f(R$_{i-1}$, K$_i$)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, below=1cm of rondas] (swap) {{Intercambio Final (R$_{16}$L$_{16}$)}};
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, below of=swap] (pf) {Permutación Final (IP$^{-1}$)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, below of=pf] (cripto) {Bloque Cifrado de 64 bits};

%     % Clave
%     \node[rectangle, draw, minimum width=3cm, minimum height=1cm, right=2cm of bloque] (clave) {Clave de 56 bits};
%     \node[rectangle, draw, minimum width=3cm, minimum height=2cm, right=2cm of rondas] (subclave) {Generación de\newline Subclaves K$_1$...K$_{16}$};

%     % Conexiones
%     \draw[->] (bloque) -- (pi);
%     \draw[->] (pi) -- (div);
%     \draw[->] (div) -- (rondas);
%     \draw[->] (rondas) -- (swap);
%     \draw[->] (swap) -- (pf);
%     \draw[->] (pf) -- (cripto);

%     \draw[->] (clave) -- (subclave);
%     \draw[->] (subclave) -- (rondas);
%     \end{tikzpicture}
%     \caption{Estructura general del algoritmo DES}
%     \label{fig:des-estructura}
% \end{figure}

\begin{cryptomethod}{Proceso de Cifrado DES}
	El proceso de cifrado DES opera a través de las siguientes etapas:

	\begin{enumerate}
		\item \textbf{Permutación Inicial}: Reordenamiento de los bits del bloque de entrada según una tabla fija.
		\item \textbf{División en Bloques}: Separación del bloque permutado en dos mitades de 32 bits (L$_0$ y R$_0$).
		\item \textbf{Rondas}: 16 iteraciones aplicando la función de DES con diferentes subclaves derivadas de la clave principal.
		\item \textbf{Intercambio Final}: Las mitades R$_{16}$L$_{16}$ se intercambian.
		\item \textbf{Permutación Final}: Aplicación de la permutación inversa a la inicial.
	\end{enumerate}

	La operación esencial dentro de cada ronda sigue la estructura de red de Feistel:
	\begin{align}
		L_i & = R_{i-1}                        \\
		R_i & = L_{i-1} \oplus f(R_{i-1}, K_i)
	\end{align}
	donde $f$ es la función de DES que combina operaciones de expansión, sustitución y permutación.
\end{cryptomethod}

\subsection{Componentes del Algoritmo DES}

\subsubsection{Permutación Inicial}
La permutación inicial (IP) reordena los 64 bits de entrada según una tabla fija. Esta operación no tiene significado criptográfico, sino que fue diseñada para facilitar la entrada/salida en hardware.

% \begin{lstlisting}[style=cryptoalgo, caption={Tabla de Permutación Inicial (IP)}, label=lst:ip]
% IP = [
%     58, 50, 42, 34, 26, 18, 10, 2,
%     60, 52, 44, 36, 28, 20, 12, 4,
%     62, 54, 46, 38, 30, 22, 14, 6,
%     64, 56, 48, 40, 32, 24, 16, 8,
%     57, 49, 41, 33, 25, 17, 9, 1,
%     59, 51, 43, 35, 27, 19, 11, 3,
%     61, 53, 45, 37, 29, 21, 13, 5,
%     63, 55, 47, 39, 31, 23, 15, 7
% ]
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}
%     \draw (0,0) grid (8,8);

%     % Etiquetas de fila
%     \foreach \y in {1,...,8}
%         \node[left] at (0, 8-\y+0.5) {Fila \y};

%     % Etiquetas de columna
%     \foreach \x in {1,...,8}
%         \node[above] at (\x-0.5, 8) {Col \x};

%     % Datos de la permutación (simplificados por claridad)
%     \node at (0.5, 7.5) {58};
%     \node at (1.5, 7.5) {50};
%     \node at (2.5, 7.5) {42};
%     \node at (7.5, 0.5) {7};

%     % Indicación de flujo
%     % \draw[->, red, thick] (0, -0.5) -- (8, -0.5);
%     \node[below] at (4, -0.5) {Dirección de lectura};
%     \end{tikzpicture}
%     \caption{Representación visual de la tabla de permutación inicial}
%     \label{fig:tabla-ip}
% \end{figure}

\subsubsection{División en Bloques}
Tras la permutación inicial, el bloque de 64 bits se divide en dos mitades de 32 bits:

% \begin{lstlisting}[style=cryptoalgo, caption={División en Bloques}, label=lst:division]
% # Después de aplicar IP a los 64 bits originales
% bloque_permutado = IP(bloque_original)

% # División en mitades izquierda (L0) y derecha (R0)
% L0 = bloque_permutado[0:32]  # Primeros 32 bits
% R0 = bloque_permutado[32:64] # Últimos 32 bits
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}
%     % Bloque original
%     \draw (0,0) rectangle (6,1);
%     \node at (3, 0.5) {Bloque permutado de 64 bits};

%     % Flecha
%     \draw[->, thick] (3, 0) -- (3, -1);

%     % Bloques divididos
%     \draw (0,-2) rectangle (3,-1);
%     \node at (1.5, -1.5) {L$_0$ (32 bits)};

%     \draw (3,-2) rectangle (6,-1);
%     \node at (4.5, -1.5) {R$_0$ (32 bits)};
%     \end{tikzpicture}
%     \caption{División del bloque permutado en dos mitades}
%     \label{fig:division-bloques}
% \end{figure}

\subsubsection{Función de DES}

La función de DES (función $f$) es el núcleo del algoritmo y se aplica en cada ronda. Toma como entrada un bloque de 32 bits (R$_{i-1}$) y una subclave de 48 bits (K$_i$), y produce una salida de 32 bits.

% \begin{lstlisting}[style=cryptoalgo, caption={Función de DES}, label=lst:funcion-des]
% def funcion_f(R, K):
%     # 1. Expansión: expandir R de 32 a 48 bits
%     E_R = expansion(R)

%     # 2. XOR con la subclave
%     B = E_R XOR K

%     # 3. División en 8 bloques de 6 bits
%     B_1, B_2, B_3, B_4, B_5, B_6, B_7, B_8 = divide_en_bloques_de_6_bits(B)

%     # 4. Aplicación de las S-Boxes (sustitución)
%     S_1 = S1_Box[B_1]  # Salida: 4 bits
%     S_2 = S2_Box[B_2]  # Salida: 4 bits
%     ...
%     S_8 = S8_Box[B_8]  # Salida: 4 bits

%     # 5. Concatenación de los resultados (32 bits)
%     S = concatenar(S_1, S_2, S_3, S_4, S_5, S_6, S_7, S_8)

%     # 6. Permutación P
%     resultado = permutacion_P(S)

%     return resultado
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}[node distance=1.2cm]
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm] (r) {R$_{i-1}$ (32 bits)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=r] (e) {Expansión E};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=e] (xor) {XOR $\oplus$};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=xor] (s) {S-Boxes (Sustitución)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=s] (p) {Permutación P};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=p] (salida) {Salida (32 bits)};

%     \node[rectangle, draw, minimum width=2cm, minimum height=0.8cm, right=1.5cm of xor] (k) {K$_i$ (48 bits)};

% \draw[->] (r) -- (e);
% \draw[->] (e) -- (xor);
% \draw[->] (xor) -- (s);
% \draw[->] (s) -- (p);
% \draw[->] (p) -- (salida);
% \draw[->] (k) -- (xor);

% Anotaciones
%     \node[right] at (e) {E(R$_{i-1}$) = 48 bits};
%     \node[right] at (s) {8 cajas de 6 bits a 4 bits};
%     \end{tikzpicture}
%     \caption{Estructura de la función $f$ de DES}
%     \label{fig:funcion-des}
% \end{figure}

\subsubsection{Transformación de la Clave}

La clave original de 56 bits (excluyendo bits de paridad) se somete a un proceso para generar 16 subclaves de 48 bits, una para cada ronda.

% \begin{lstlisting}[style=cryptoalgo, caption={Generación de Subclaves}, label=lst:generacion-subclaves]
% # Permutación inicial de la clave PC-1
% def generacion_subclaves(clave_original):
%     # Eliminar bits de paridad (posiciones 8, 16, 24, 32, 40, 48, 56, 64)
%     # y aplicar permutación PC-1
%     clave_56bits = PC1(clave_original)  # De 64 a 56 bits

%     # Dividir en dos mitades
%     C0 = clave_56bits[0:28]   # Bits 1-28
%     D0 = clave_56bits[28:56]  # Bits 29-56

%     subclaves = []

%     # Generar 16 subclaves
%     for i in range(1, 17):
%         # Rotación circular izquierda
%         # 1 posición en las rondas 1, 2, 9, 16
%         # 2 posiciones en las demás rondas
%         if i in [1, 2, 9, 16]:
%             C_i = rotacion_izquierda(C_{i-1}, 1)
%             D_i = rotacion_izquierda(D_{i-1}, 1)
%         else:
%             C_i = rotacion_izquierda(C_{i-1}, 2)
%             D_i = rotacion_izquierda(D_{i-1}, 2)

%         # Concatenar C_i y D_i
%         CD_i = C_i + D_i

%         # Aplicar permutación PC-2 para obtener subclave de 48 bits
%         K_i = PC2(CD_i)  # De 56 a 48 bits

%         subclaves.append(K_i)

%     return subclaves
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}[node distance=1.2cm]
%     % Entrada y PC-1
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm] (k64) {Clave Original (64 bits)};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=k64] (pc1) {Permutación PC-1};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, below of=pc1] (k56) {Clave (56 bits)};

%     % División
%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below left=1cm and 0.5cm of k56] (c0) {C$_0$ (28 bits)};
%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below right=1cm and 0.5cm of k56] (d0) {D$_0$ (28 bits)};

%     % Rotaciones y subclaves
%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below of=c0] (c1) {C$_1$};
%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below of=d0] (d1) {D$_1$};

%     \node[below=0.5cm of c1] (cdots1) {$\vdots$};
%     \node[below=0.5cm of d1] (cdots2) {$\vdots$};

%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below=1cm of cdots1] (c16) {C$_{16}$};
%     \node[rectangle, draw, minimum width=1.5cm, minimum height=0.8cm, below=1cm of cdots2] (d16) {D$_{16}$};

%     % PC-2 y subclaves
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, right=2.5cm of c1] (k1) {K$_1$ (48 bits)};
%     \node[right=2.5cm of cdots1] (kdots) {$\vdots$};
%     \node[rectangle, draw, minimum width=3cm, minimum height=0.8cm, right=2.5cm of c16] (k16) {K$_{16}$ (48 bits)};

% Conexiones
% \draw[->] (k64) -- (pc1);
% \draw[->] (pc1) -- (k56);
% \draw[->] (k56) -| (c0);
% \draw[->] (k56) -| (d0);

% \draw[->] (c0) -- (c1) node[midway, left] {LS-1};
% \draw[->] (d0) -- (d1) node[midway, right] {LS-1};

% \draw[->] (c1) -- (cdots1);
% \draw[->] (d1) -- (cdots2);

% \draw[->] (cdots1) -- (c16);
% \draw[->] (cdots2) -- (d16);

% % PC-2 conexiones
% \draw[->] (c1) -- ($(c1)!0.5!(d1)$) |- (k1) node[pos=0.75, above] {PC-2};
% \draw[->] (d1) -- ($(c1)!0.5!(d1)$);

% \draw[->] (c16) -- ($(c16)!0.5!(d16)$) |- (k16) node[pos=0.75, above] {PC-2};
% \draw[->] (d16) -- ($(c16)!0.5!(d16)$);
% \end{tikzpicture}
% \caption{Proceso de generación de subclaves en DES}
% \label{fig:generacion-subclaves}
% \end{figure}

\subsubsection{Matriz de Expansión}

La matriz de expansión E transforma un bloque de 32 bits en uno de 48 bits, expandiendo ciertos bits para mejorar el efecto de difusión.

% \begin{lstlisting}[style=cryptoalgo, caption={Matriz de Expansión E}, label=lst:matriz-expansion]
% E = [
%     32, 1, 2, 3, 4, 5,
%     4, 5, 6, 7, 8, 9,
%     8, 9, 10, 11, 12, 13,
%     12, 13, 14, 15, 16, 17,
%     16, 17, 18, 19, 20, 21,
%     20, 21, 22, 23, 24, 25,
%     24, 25, 26, 27, 28, 29,
%     28, 29, 30, 31, 32, 1
% ]
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}
%     % Bloque de entrada
%     \draw (0,0) rectangle (8,0.8);
%     \node at (4, 0.4) {Bloque de 32 bits};

%     % Flecha
%     % \draw[->, thick] (4, 0) -- (4, -1);

%     % Bloque expandido
%     \draw (0,-2) rectangle (12,-1);
%     \node at (6, -1.5) {Bloque expandido de 48 bits};

%     % Indicadores de expansión
%     % \draw[<->, red] (0,-2.2) -- (12,-2.2) node[midway, below] {Expansión};
%     \end{tikzpicture}
%     \caption{Representación de la expansión de 32 a 48 bits}
%     \label{fig:expansion}
% \end{figure}

\subsubsection{Cajas de Sustitución (S-Boxes)}

Las cajas S son el componente no lineal de DES. Cada caja S toma 6 bits de entrada y produce 4 bits de salida según tablas predefinidas.

% \begin{lstlisting}[style=cryptoalgo, caption={Ejemplo de S-Box (S1)}, label=lst:sbox]
% S1 = [
%     [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
%     [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
%     [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
%     [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
% ]

% # Uso de la S-Box:
% # Los bits 1 y 6 determinan la fila (0-3)
% # Los bits 2-5 determinan la columna (0-15)
% # Ejemplo: Para entrada 010011
% # Fila = 01 binario = 1
% # Columna = 1001 binario = 9
% # Resultado = S1[1][9] = 6 = 0110 binario
% \end{lstlisting}

% \begin{figure}[ht]
%     \centering
%     \begin{tikzpicture}
%     % S-Boxes
%     \foreach \i in {1,...,8} {
%         \draw (0, -\i+1) rectangle (2, -\i+2);
%         \node at (1, -\i+1.5) {S-Box \i};

%         % Entradas y salidas
%         \draw[->] (-1.5, -\i+1.5) -- (0, -\i+1.5);
%         \node[left] at (-1.5, -\i+1.5) {6 bits};

%         \draw[->] (2, -\i+1.5) -- (3.5, -\i+1.5);
%         \node[right] at (3.5, -\i+1.5) {4 bits};
%     % }

%     \node at (1, -9) {Total: 48 bits entrada → 32 bits salida};
%     \end{tikzpicture}
%     \caption{Conjunto de 8 S-Boxes en DES}
%     \label{fig:sboxes}
% \end{figure}

\subsubsection{Permutación Final}

La permutación final (IP$^{-1}$) es la inversa de la permutación inicial, completando el proceso de cifrado.

% \begin{lstlisting}[style=cryptoalgo, caption={Permutación Final}, label=lst:permutacion-final]
% IP_inversa = [
%     40, 8, 48, 16, 56, 24, 64, 32,
%     39, 7, 47, 15, 55, 23, 63, 31,
%     38, 6, 46, 14, 54, 22, 62, 30,
%     37, 5, 45, 13, 53, 21, 61, 29,
%     36, 4, 44, 12, 52, 20, 60, 28,
%     35, 3, 43, 11, 51, 19, 59, 27,
%     34, 2, 42, 10, 50, 18, 58, 26,
%     33, 1, 41, 9, 49, 17, 57, 25
% ]
% \end{lstlisting}

\subsection{Implementación en Código}

A continuación, se presenta un fragmento de código en Python que ilustra la implementación de algunos componentes clave del algoritmo DES:

\begin{lstlisting}[language=Python, caption={Fragmento de implementación de DES en Python}, label=lst:des-python]

# Tablas de permutación (fragmentos)
IP = [58, 50, 42, 34, 26, 18, 10, 2, ..., 63, 55, 47, 39, 31, 23, 15, 7]
IP_inv = [40, 8, 48, 16, 56, 24, 64, 32, ..., 33, 1, 41, 9, 49, 17, 57, 25]
E = [32, 1, 2, 3, 4, 5, ..., 28, 29, 30, 31, 32, 1]
P = [16, 7, 20, 21, ..., 13, 27, 6]

# S-Boxes (solo S1 por brevedad)
S1 = [
    [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
    [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
    [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
    [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
]

def permutacion(bloque, tabla):
    """Aplica una permutación según la tabla dada"""
    return [bloque[i-1] for i in tabla]

def dividir_bloque(bloque):
    """Divide un bloque en dos mitades"""
    mitad = len(bloque) // 2
    return bloque[:mitad], bloque[mitad:]

def expansion(R):
    """Expande un bloque de 32 bits a 48 bits"""
    return permutacion(R, E)

def aplicar_sbox(B, s_box):
    """Aplica una S-Box a un bloque de 6 bits"""
    # Primer y último bit determinan la fila
    fila = (B[0] << 1) + B[5]
    # Bits centrales determinan la columna
    columna = (B[1] << 3) + (B[2] << 2) + (B[3] << 1) + B[4]
    # Convertir el valor a binario de 4 bits
    valor = s_box[fila][columna]
    return [(valor >> 3) & 1, (valor >> 2) & 1, (valor >> 1) & 1, valor & 1]

def funcion_f(R, K):
    """Función principal de DES"""
    # Expansión
    E_R = expansion(R)

    # XOR con la subclave
    B = [E_R[i] ^ K[i] for i in range(48)]

    # Dividir en bloques de 6 bits
    bloques = [B[i:i+6] for i in range(0, 48, 6)]

    # Aplicar S-Boxes
    resultado = []
    for i in range(8):
        resultado.extend(aplicar_sbox(bloques[i], [S1, S2, S3, S4, S5, S6, S7, S8][i]))

    # Permutación P
    return permutacion(resultado, P)

def cifrar_des(bloque, claves):
    """Cifra un bloque usando DES"""
    # Permutación inicial
    bloque = permutacion(bloque, IP)

    # División en bloques L y R
    L, R = dividir_bloque(bloque)

    # 16 rondas
    for i in range(16):
        L, R = R, [L[j] ^ funcion_f(R, claves[i])[j] for j in range(32)]

    # Intercambio final
    resultado = R + L

    # Permutación final
    return permutacion(resultado, IP_inv)
\end{lstlisting}


% ------------------------------------------
% Code DES
% ------------------------------------------

% subKeyList = 16*[[None]*8]

% IPtable = (58, 50, 42, 34, 26, 18, 10, 2,
%            60, 52, 44, 36, 28, 20, 12, 4,
%            62, 54, 46, 38, 30, 22, 14, 6,
%            64, 56, 48, 40, 32, 24, 16, 8,
%            57, 49, 41, 33, 25, 17,  9, 1,
%            59, 51, 43, 35, 27, 19, 11, 3,
%            61, 53, 45, 37, 29, 21, 13, 5,
%            63, 55, 47, 39, 31, 23, 15, 7)

% EPtable = (32,  1,  2,  3,  4,  5,
%             4,  5,  6,  7,  8,  9,
%             8,  9, 10, 11, 12, 13,
%            12, 13, 14, 15, 16, 17,
%            16, 17, 18, 19, 20, 21,
%            20, 21, 22, 23, 24, 25,
%            24, 25, 26, 27, 28, 29,
%            28, 29, 30, 31, 32,  1)

% PFtable = (16,  7, 20, 21, 29, 12, 28, 17,
%             1, 15, 23, 26,  5, 18, 31, 10,
%             2,  8, 24, 14, 32, 27,  3,  9,
%            19, 13, 30,  6, 22, 11,  4, 25)

% FPtable = (40, 8, 48, 16, 56, 24, 64, 32,
%            39, 7, 47, 15, 55, 23, 63, 31,
%            38, 6, 46, 14, 54, 22, 62, 30,
%            37, 5, 45, 13, 53, 21, 61, 29,
%            36, 4, 44, 12, 52, 20, 60, 28,
%            35, 3, 43, 11, 51, 19, 59, 27,
%            34, 2, 42, 10, 50, 18, 58, 26,
%            33, 1, 41,  9, 49, 17, 57, 25)

% sBox = 8*[64*[0]]

% sBox[0] = (14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,
%             0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,
%             4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,
%            15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13)

% sBox[1] = (15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,
%             3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,
%             0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,
%            13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9)

% sBox[2] = (10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,
%            13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,
%            13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,
%             1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12)

% sBox[3] = ( 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,
%            13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,
%            10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,
%             3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14)

% sBox[4] = ( 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,
%            14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,
%             4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,
%            11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3)

% sBox[5] = (12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,
%            10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,
%             9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,
%             4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13)

% sBox[6] = ( 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,
%            13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,
%             1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,
%             6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12)

% sBox[7] = (13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,
%             1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,
%             7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,
%             2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11)

% def main():
%     key = [0x70, 0x72, 0x75, 0x65, 0x62, 0x69, 0x74, 0x61]
%     key2 = [0x70, 0x72, 0x75, 0x65, 0x62, 0x69, 0x74, 0x62]
%     pt1 = "prueba de ser un texto cifrable"
%     print("Texto Plano")
%     print(pt1)
%     ciphertext = encrypt(key, pt1)
%     print("Texto Cifrado")
%     print(ciphertext)
%     print("Texto Descifrado")
%     decryptText = decrypt(key, ciphertext)
%     #Unit Test for Not symetric KEY fail
%     #decryptText = decrypt(key2, ciphertext)
%     print(decryptText)
%     assert decryptText == pt1
%     print("ok Verify DES")


% def bit2Byte(bitList):
%     """Convert bit list into a byte list"""
%     return [int("".join(map(str,bitList[i*8:i*8+8])),2) for i in range(len(bitList)//8)]

% def byte2Bit(byteList):
%     """Convert byte list into a bit list"""
%     return [(byteList[i//8]>>(7-(i%8)))&0x01 for i in range(8*len(byteList))]

% def permBitList(inputBitList,permTable):
%     """Permute input bit list according to input permutation table"""
%     return [inputBitList[e - 1] for e in permTable]

% def permByteList(inByteList,permTable):
%     """Permute input byte list according to input permutation table"""
%     outByteList = (len(permTable)>>3)*[0]
%     for index,elem in enumerate(permTable):
%         i = index%8
%         e = (elem-1)%8
%         if i>=e:
%             outByteList[index>>3] |= \
%                 (inByteList[(elem-1)>>3]&(128>>e))>>(i-e)
%         else:
%             outByteList[index>>3] |= \
%                 (inByteList[(elem-1)>>3]&(128>>e))<<(e-i)
%     return outByteList

% def getIndex(inBitList):
%     """Permute bits to properly index the S-boxes"""
%     return (inBitList[0]<<5)+(inBitList[1]<<3)+ \
%            (inBitList[2]<<2)+(inBitList[3]<<1)+ \
%            (inBitList[4]<<0)+(inBitList[5]<<4)

% def padData(string):
%     """Add PKCS5 padding to plaintext"""
%     padLength = 8-(len(string)%8)
%     return [ord(s) for s in string]+padLength*[padLength]

% def unpadData(byteList):
%     """Remove PKCS5 padding from plaintext"""
%     return "".join(chr(e) for e in byteList[:-byteList[-1]])

% def setKey(keyByteList):
%     """Generate all sixteen round subkeys"""
%     PC1table = (57, 49, 41, 33, 25, 17,  9,
%                  1, 58, 50, 42, 34, 26, 18,
%                 10,  2, 59, 51, 43, 35, 27,
%                 19, 11,  3, 60, 52, 44, 36,
%                 63, 55, 47, 39, 31, 23, 15,
%                  7, 62, 54, 46, 38, 30, 22,
%                 14,  6, 61, 53, 45, 37, 29,
%                 21, 13,  5, 28, 20, 12,  4)

%     PC2table= (14, 17, 11, 24,  1,  5,  3, 28,
%                15,  6, 21, 10, 23, 19, 12,  4,
%                26,  8, 16,  7, 27, 20, 13,  2,
%                41, 52, 31, 37, 47, 55, 30, 40,
%                51, 45, 33, 48, 44, 49, 39, 56,
%                34, 53, 46, 42, 50, 36, 29, 32)

%     def leftShift(inKeyBitList,round):
%         """Perform one (or two) circular left shift(s) on key"""
%         LStable = (1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1)

%         outKeyBitList = 56*[0]
%         if LStable[round] == 2:
%             outKeyBitList[:26] = inKeyBitList[2:28]
%             outKeyBitList[26] = inKeyBitList[0]
%             outKeyBitList[27] = inKeyBitList[1]
%             outKeyBitList[28:54] = inKeyBitList[30:]
%             outKeyBitList[54] = inKeyBitList[28]
%             outKeyBitList[55] = inKeyBitList[29]
%         else:
%             outKeyBitList[:27] = inKeyBitList[1:28]
%             outKeyBitList[27] = inKeyBitList[0]
%             outKeyBitList[28:55] = inKeyBitList[29:]
%             outKeyBitList[55] = inKeyBitList[28]
%         return outKeyBitList

%     permKeyBitList = permBitList(byte2Bit(keyByteList),PC1table)
%     for round in range(16):
%         auxBitList = leftShift(permKeyBitList,round)
%         subKeyList[round] = bit2Byte(permBitList(auxBitList,PC2table))
%         permKeyBitList = auxBitList

% def encryptBlock(inputBlock):
%   """Encrypt an 8-byte block with already defined key"""
%   inputData = permByteList(inputBlock,IPtable)
%   leftPart,rightPart = inputData[:4],inputData[4:]
%   for round in range(16):
%         expRightPart = permByteList(rightPart,EPtable)
%         key = subKeyList[round]
%         indexList = byte2Bit([i^j for i,j in zip(key,expRightPart)])
%         sBoxOutput = 4*[0]
%         for nBox in range(4):
%             nBox12 = 12*nBox
%             leftIndex = getIndex(indexList[nBox12:nBox12+6])
%             rightIndex = getIndex(indexList[nBox12+6:nBox12+12])
%             sBoxOutput[nBox] = (sBox[nBox<<1][leftIndex]<<4)+ \
%                                 sBox[(nBox<<1)+1][rightIndex]
%         aux = permByteList(sBoxOutput,PFtable)
%         newRightPart = [i^j for i,j in zip(aux,leftPart)]
%         leftPart = rightPart
%         rightPart = newRightPart
%   return permByteList(rightPart+leftPart,FPtable)

% def decryptBlock(inputBlock):
%     """Decrypt an 8-byte block with already defined key"""
%     inputData = permByteList(inputBlock,IPtable)
%     leftPart,rightPart = inputData[:4],inputData[4:]
%     for round in range(16):
%         expRightPart = permByteList(rightPart,EPtable)
%         key = subKeyList[15-round]
%         indexList = byte2Bit([i^j for i,j in zip(key,expRightPart)])
%         sBoxOutput = 4*[0]
%         for nBox in range(4):
%             nBox12 = 12*nBox
%             leftIndex = getIndex(indexList[nBox12:nBox12+6])
%             rightIndex = getIndex(indexList[nBox12+6:nBox12+12])
%             sBoxOutput[nBox] = (sBox[nBox*2][leftIndex]<<4)+ \
%                                 sBox[nBox*2+1][rightIndex]
%         aux = permByteList(sBoxOutput,PFtable)
%         newRightPart = [i^j for i,j in zip(aux,leftPart)]
%         leftPart = rightPart
%         rightPart = newRightPart
%     return permByteList(rightPart+leftPart,FPtable)

% def encrypt(key, inString):
% #Encrypt plaintext with given key"""
%   setKey(key)
%   inByteList,outByteList = padData(inString),[]
%   for i in range(0,len(inByteList),8):
%       outByteList += encryptBlock(inByteList[i:i+8])
%   return outByteList

% def decrypt(key, inByteList):
%     """Decrypt ciphertext with given key"""
%     setKey(key)
%     outByteList = []
%     for i in range(0,len(inByteList),8):
%         outByteList += decryptBlock(inByteList[i:i+8])
%     return unpadData(outByteList)

% if __name__ == '__main__':
%     main()
